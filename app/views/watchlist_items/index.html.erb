<div class="container-fluid">
  <div class="row">
    <div class="col-12 mb-4">
      <h1 class="display-4 text-center">My Watchlist</h1>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header unwatched-header">
          <h2 class="h4 mb-0">Unwatched</h2>
        </div>
        <div class="card-body unwatched-body" id="unwatched-list" data-controller="sortable" data-sortable-resource-url="/watchlist_items/">
          <%= render partial: 'watchlist_card', collection: @unwatched_items.compact, as: :item %>
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <div class="card mb-4">
        <div class="card-header watched-header">
          <h2 class="h4 mb-0">Watched</h2>
        </div>
        <div class="card-body watched-body" id="watched-list" data-controller="sortable" data-sortable-resource-url="/watchlist_items/">
          <%= render partial: 'watchlist_card', collection: @watched_items.compact, as: :item %>
        </div>
      </div>
    </div>
  </div>
</div>

<%= render 'shared/details_modal' %>

<script>
document.addEventListener('DOMContentLoaded', function() {
  attachEventListeners();
  updateWatchlistNavbar();
  ['watched-list', 'unwatched-list'].forEach(listId => {
    const list = document.getElementById(listId);
    if (list) {
      new Sortable(list, {
        handle: '.drag-handle',
        animation: 150,
        group: listId,
        onEnd: function(evt) {
          const sourceId = evt.item.dataset.sourceId;
          const contentType = evt.item.dataset.contentType;
          const newPosition = Array.from(evt.item.parentNode.children)
            .filter(child => child.classList.contains('watchlist-item'))
            .indexOf(evt.item) + 1;
          const isWatched = evt.item.querySelector('.mark-unwatched') !== null;
          
          fetch(`/watchlist_items/${sourceId}/reposition`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
            },
            body: JSON.stringify({
              watchlist_item: {
                position: newPosition,
                content_type: contentType,
                watched: isWatched
              }
            })
          })
          .then(response => {
            if (!response.ok) {
              throw new Error('Reposition failed');
            }
            return response.json();
          })
          .then(data => {
            if (data.status === 'success') {
              updateWatchlistNavbar();
            }
          })
          .catch(error => {
            console.error('Error:', error);
            evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
          });
        }
      });
    }
  });
});

function handleWatchlistAction(action, sourceId, contentType, element) {
  let url, method;
  if (action === 'toggleWatched') {
    url = `/watchlist_items/${sourceId}/toggle_watched`;
    method = 'POST';
  } else if (action === 'removeItem') {
    url = `/watchlist_items/${sourceId}`;
    method = 'DELETE';
  } else if (action === 'addItem') {
    url = `/watchlist_items`;
    method = 'POST';
  }

  return fetch(url, {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
    },
    body: JSON.stringify({
      watchlist_item: { 
        source_id: sourceId,
        content_type: contentType 
      }
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      const popup = document.querySelector('#popup-details');
      if (action === 'removeItem') {
        if (!popup || !popup.contains(element)) {
          updateWatchlistUI(sourceId, false, false, null);
        }
        updatePopupUI(popup, sourceId, false, false, null);
      } else if (action === 'addItem') {
        updateWatchlistUI(sourceId, true, false, null);
        updatePopupUI(popup, sourceId, true, false, null);
      } else {
        updateWatchlistUI(sourceId, true, data.watched, data.rating);
        if (popup) {
          updatePopupUI(popup, sourceId, true, data.watched, data.rating);
        }
      }
      updateWatchlistNavbar();
    }
    return data;
  });
}

function updateWatchlistUI(sourceId, inWatchlist, watched, rating, showRatingPopup = true) {
  const card = document.querySelector(`.watchlist-item[data-source-id="${sourceId}"]`);
  if (!card) return;

  // If item is not in watchlist, remove the card
  if (!inWatchlist) {
    card.remove();
    return;
  }

  const buttonsContainer = card.querySelector('.card-buttons');
  if (buttonsContainer) {
    buttonsContainer.className = 'd-flex gap-2 justify-content-between';
  }

  // Update watched/unwatched button
  const watchButton = card.querySelector('.mark-watched, .mark-unwatched');
  if (watchButton) {
    watchButton.className = `btn btn-sm flex-grow-1 ${watched ? 'btn-warning mark-unwatched' : 'btn-success mark-watched'}`;
    watchButton.innerHTML = `
      <i class="fas ${watched ? 'fa-eye-slash' : 'fa-eye'} me-1"></i>
      <span>${watched ? 'Unwatched' : 'Watched'}</span>
    `;
  }

  // Update rate button
  const rateButton = card.querySelector('.rate-item');
  if (rateButton) {
    if (rating) {
      rateButton.className = 'btn btn-sm btn-warning rate-item rated flex-grow-1';
      rateButton.innerHTML = `<i class="fas fa-star me-1"></i><span>Rated (${rating}/10)</span>`;
      rateButton.dataset.rating = rating;
    } else {
      rateButton.className = 'btn btn-sm btn-primary rate-item flex-grow-1';
      rateButton.innerHTML = `<i class="fas fa-star me-1"></i><span>Rate</span>`;
      rateButton.dataset.rating = '0';
    }
  }

  // Move card to appropriate section
  const targetList = watched ? 
    document.getElementById('watched-list') : 
    document.getElementById('unwatched-list');
  
  if (targetList && card.parentElement !== targetList) {
    targetList.appendChild(card);
  }

  // Update popup if open
  const popup = document.querySelector('#popup-details');
  if (popup && popup.querySelector(`[data-source-id="${sourceId}"]`)) {
    updatePopupUI(popup, sourceId, inWatchlist, watched, rating, showRatingPopup);
  }
}

function showDetailsPopup(sourceId, contentType) {
  console.log('showDetailsPopup called with:', sourceId, contentType);
  fetch(`/recommendations/${sourceId}?type=${contentType}`)
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log('Recommendation data received:', data);
      return fetch(`/watchlist_items/status?source_id=${sourceId}&content_type=${contentType}`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Watchlist status fetch failed');
          }
          return response.json();
        })
        .then(watchlistData => {
          console.log('Watchlist status received:', watchlistData);
          const country = data.production_countries 
            ? data.production_countries.map(c => c.name === 'United States of America' ? 'USA' : c.name).join(', ') 
            : 'N/A';
          return { ...data, inWatchlist: watchlistData.in_watchlist, watched: watchlistData.watched, rating: watchlistData.rating, country };
        });
    })
    .then(data => {
      const modalContent = generateModalContent(data);
      document.getElementById('popup-details').innerHTML = modalContent;
      new bootstrap.Modal(document.getElementById('detailsModal')).show();
      updatePopupUI(document.getElementById('popup-details'), data.source_id, data.inWatchlist, data.watched, data.rating);
      setupRatingHandlers(document.getElementById('popup-details'));
    })
    .catch(error => {
      console.error('Error:', error);
      showError('Failed to load details. Please try again.');
    });
}

function generateModalContent(data) {
  var details = `
    <div class="row">
      <div class="col-md-4 mb-3 mb-md-0">
        <img src="https://image.tmdb.org/t/p/w500${data.poster_path}" class="img-fluid rounded" alt="${data.title || data.name} poster" role="img">
      </div>
      <div class="col-md-8">
        <div class="d-flex justify-content-between align-items-start mb-3">
          <div>
            <h2 class="text-warning mb-2">${data.title || data.name}</h2>
            <p class="mb-1"><strong>Runtime:</strong> ${data.runtime || (data.episode_run_time && data.episode_run_time[0]) || 'N/A'} minutes</p>
            <p class="mb-1"><strong>Release Year:</strong> ${(data.release_date || data.first_air_date || '').substring(0, 4)}</p>
            <p class="mb-1"><strong>Country:</strong> ${data.country || 'N/A'}</p>
            <p class="mb-1"><strong>TMDb Rating:</strong> ${data.vote_average?.toFixed(1) || 'N/A'} (${data.vote_count?.toLocaleString() || 0} votes)</p>
          </div>
          <div class="d-flex flex-column">
            <button class="btn btn-primary watchlist-toggle mb-2 ${data.inWatchlist ? 'in-watchlist' : ''}" 
                    data-source-id="${data.source_id}"
                    data-content-type="${data.content_type}"
                    aria-label="${data.inWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}">
              <i class="fas fa-bookmark ${data.inWatchlist ? 'text-warning' : 'text-muted'}"></i>
              <span class="watchlist-text ms-1">${data.inWatchlist ? 'Remove' : 'Add'}</span>
            </button>
            <button class="btn btn-secondary watched-toggle mb-2 ${data.watched ? 'watched' : ''}" 
                    onclick="toggleWatched(event, '${data.source_id}', '${data.content_type}')"
                    data-source-id="${data.source_id}"
                    data-content-type="${data.content_type}"
                    style="display: ${data.inWatchlist ? 'block' : 'none'};">
              <i class="fas ${data.watched ? 'fa-eye-slash' : 'fa-eye'}"></i>
              <span class="watched-text ms-1">${data.watched ? 'Mark as Unwatched' : 'Mark as Watched'}</span>
            </button>
            <button class="btn btn-warning rate-item ${data.rating ? 'rated' : ''}"
                    data-source-id="${data.source_id}"
                    data-content-type="${data.content_type}"
                    data-rating="${data.rating || 0}"
                    style="display: ${data.inWatchlist && data.watched ? 'block' : 'none'};">
              <i class="fas fa-star"></i>
              <span class="rate-text">Rate${data.rating ? `d (${data.rating})` : ''}</span>
            </button>
            <div id="rating-container" class="rating-interface" style="display: none;">
              <div class="rating-stars">
                ${[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(star => `
                  <span class="star" data-value="${star}">★</span>
                `).join('')}
              </div>
              <div class="rating-actions">
                <button class="btn btn-sm btn-primary submit-rating">Submit</button>
                <button class="btn btn-sm btn-secondary cancel-rating">Cancel</button>
              </div>
            </div>
          </div>
        </div>
        <p><strong>Genres:</strong> ${(data.genres || []).map(g => typeof g === 'string' ? g : g.name).join(', ')}</p>
        <p><strong>Description:</strong> ${data.overview}</p>
        ${data.content_type === 'movie' ?
          `<p><strong>Director(s):</strong> ${(data.credits?.crew || []).filter(c => c.job === 'Director').map(d => d.name).join(', ') || 'N/A'}</p>` :
          `<div>
            <p><strong>Creator(s):</strong> ${data.creators ? data.creators.join(', ') : 'N/A'}</p>
            <p><strong>Number of Seasons:</strong> ${data.number_of_seasons || 'N/A'}</p>
            <p><strong>Number of Episodes:</strong> ${data.number_of_episodes || 'N/A'}</p>
            <p><strong>Status:</strong> ${data.status || 'N/A'}</p>
          </div>`
        }
        <p><strong>Cast:</strong> ${(data.credits?.cast || []).slice(0, 5).map(c => c.name).join(', ') || 'N/A'}</p>
        <p><strong>Spoken Languages:</strong> ${(data.spoken_languages || []).map(l => l.name).join(', ') || 'N/A'}</p>
      </div>
    </div>
    ${data.trailer_url ? `
      <div class="embed-responsive embed-responsive-16by9 mt-3">
        <iframe class="embed-responsive-item" width="100%" height="315" 
                src="${data.trailer_url.replace('watch?v=', 'embed/')}" 
                allowfullscreen 
                title="${data.title || data.name} trailer"></iframe>
      </div>
    ` : ''}
  `;
  return details;
}

function updateWatchlistNavbar() {
  Promise.all([
    fetch('/watchlist_items/count').then(response => {
      if (!response.ok) throw new Error('Count fetch failed');
      return response.json();
    }),
    fetch('/watchlist_items/recent').then(response => {
      if (!response.ok) throw new Error('Recent fetch failed');
      return response.json();
    })
  ])
    .then(([countData, recentData]) => {
      const badge = document.querySelector('#watchlist-count');
      if (badge) {
        badge.textContent = countData.count;
        badge.style.display = countData.count > 0 ? 'inline-block' : 'none';
      }

      const dropdown = document.querySelector('#watchlist-dropdown');
      if (dropdown) {
        if (recentData.items && recentData.items.length > 0) {
          dropdown.innerHTML = recentData.items.map(item => `
            <li><a class="dropdown-item" href="/watchlist_items">
              <img src="${item.poster_url}" alt="${item.title}" class="me-2" style="width: 30px; height: 45px; object-fit: cover;">
              <span>${item.title} (${item.year})</span>
            </a></li>
          `).join('') + `
            <li><hr class="dropdown-divider"></li>
            <li><a class="dropdown-item text-primary" href="/watchlist_items">View All</a></li>
          `;
        } else {
          dropdown.innerHTML = '<li><span class="dropdown-item">No items in watchlist</span></li>';
        }
      }
      console.log('Watchlist navbar updated successfully');
      console.log('Count data:', countData);
      console.log('Recent data:', recentData);
    })
    .catch(error => console.error('Error updating watchlist navbar:', error));
}

function toggleWatchlist(event, sourceId, contentType) {
  event.preventDefault();
  event.stopPropagation();
  console.log('toggleWatchlist called');

  const button = event.currentTarget;
  const inWatchlist = button.classList.contains('in-watchlist');

  // Immediately update UI
  updateWatchlistUI(sourceId, !inWatchlist, false);

  const method = inWatchlist ? 'DELETE' : 'POST';
  const url = inWatchlist ? `/watchlist_items/${sourceId}` : '/watchlist_items';
  
  fetch(url, {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
    },
    body: JSON.stringify({
      watchlist_item: {
        source_id: sourceId,
        content_type: contentType
      }
    })
  })
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    if (data.status === 'success') {
      updateWatchlistUI(sourceId, !inWatchlist, false);
      updateWatchlistNavbar();
    }
  })
  .catch(error => {
    console.error('Error:', error);
    // Revert UI on error
    updateWatchlistUI(sourceId, inWatchlist, false);
  });
}

function createWatchlistCard(item) {
  console.log('Creating watchlist card for item:', item);
  const targetList = item.watched ? document.getElementById('watched-list') : document.getElementById('unwatched-list');
  if (targetList) {
    const newCard = document.createElement('div');
    newCard.className = 'card mb-3 watchlist-item';
    newCard.setAttribute('data-id', item.id);
    newCard.setAttribute('data-source-id', item.source_id);
    newCard.setAttribute('data-content-type', item.content_type);
    newCard.setAttribute('role', 'article');
    newCard.setAttribute('aria-labelledby', `title-${item.source_id}`);

    newCard.innerHTML = `
      <div class="row g-0">
        <div class="col-4">
          <img src="${item.poster_url}" class="img-fluid rounded-start" alt="${item.title} poster">
        </div>
        <div class="col-8">
          <div class="card-body position-relative">
            <h5 class="card-title mb-1" id="title-${item.source_id}">${item.title}</h5>
            <div class="card-text small">
              ${[item.release_year, item.content_type.charAt(0).toUpperCase() + item.content_type.slice(1)].filter(Boolean).join(", ")}<br>
              <strong>TMDb:</strong> ${item.vote_average}<br>
              ${item.genres.join(", ")}
            </div>
            <div class="d-flex justify-content-between align-items-center mt-2">
              <button class="btn btn-sm ${item.watched ? 'btn-warning mark-unwatched' : 'btn-success mark-watched'}" 
                      data-source-id="${item.source_id}" 
                      data-content-type="${item.content_type}">
                <i class="fas ${item.watched ? 'fa-eye-slash' : 'fa-eye'} me-1"></i>
                ${item.watched ? 'Unwatched' : 'Watched'}
              </button>
              <button class="btn btn-sm btn-danger remove-item" 
                      data-source-id="${item.source_id}" 
                      data-content-type="${item.content_type}">
                <i class="fas fa-trash-alt me-1"></i>
                Remove
              </button>
            </div>
          </div>
        </div>
      </div>
      <div class="drag-handle position-absolute top-0 start-0 p-2 text-white">
        <i class="fas fa-grip-vertical"></i>
      </div>
    `;

    targetList.appendChild(newCard);
    console.log('New card added to the DOM:', newCard);

    // Attach event listeners to the new card
    attachCardEventListeners(newCard);
  } else {
    console.error('Target list not found for item:', item);
  }
}

function handleRating(sourceId, contentType, currentRating = 0) {
  const card = document.querySelector(`.watchlist-item[data-source-id="${sourceId}"]`);
  const title = card.querySelector('.card-title').textContent.trim();
  const isWatched = card.querySelector('.mark-unwatched') !== null;
  
  if (!isWatched) {
    // If not watched, first show rating popup, then mark as watched
    return createRatingPopup(sourceId, contentType, title, currentRating)
      .then(rating => {
        return handleWatchlistAction('toggleWatched', sourceId, contentType, null)
          .then(() => {
            return submitRating(sourceId, contentType, rating);
          });
      });
  } else {
    // If already watched, just show rating popup
    return createRatingPopup(sourceId, contentType, title, currentRating)
      .then(rating => {
        return submitRating(sourceId, contentType, rating);
      });
  }
}

function submitRating(sourceId, contentType, rating) {
  return fetch(`/watchlist_items/rate`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
    },
    body: JSON.stringify({
      watchlist_item: {
        source_id: sourceId,
        content_type: contentType,
        rating: rating
      }
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      updateWatchlistUI(sourceId, true, true, data.rating, false);
      return data;
    } else {
      throw new Error(data.message);
    }
  });
}

function createRatingPopup(sourceId, contentType, title, currentRating = 0) {
  const popup = document.createElement('div');
  popup.className = 'rating-popup';
  popup.dataset.sourceId = sourceId;
  popup.dataset.contentType = contentType;
  popup.innerHTML = `
    <h3>${title}</h3>
    <div class="rating-stars">
      ${[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(star => `
        <span class="star ${star <= currentRating ? 'active' : ''}" data-value="${star}">★</span>
      `).join('')}
    </div>
    <button class="btn btn-sm btn-primary submit-rating">Submit</button>
    <button class="btn btn-sm btn-secondary cancel-rating">Cancel</button>
  `;

  document.body.appendChild(popup);

  const stars = popup.querySelectorAll('.star');
  stars.forEach(star => {
    star.addEventListener('click', () => {
      const value = parseInt(star.dataset.value);
      stars.forEach(s => s.classList.toggle('active', parseInt(s.dataset.value) <= value));
    });
  });

  return new Promise((resolve, reject) => {
    popup.querySelector('.submit-rating').addEventListener('click', () => {
      const rating = popup.querySelectorAll('.star.active').length;
      submitRating(popup.dataset.sourceId, popup.dataset.contentType, rating)
        .then(data => {
          document.body.removeChild(popup);
          resolve(rating);
        })
        .catch(error => {
          console.error('Error submitting rating:', error);
          reject(error);
        });
    });

    popup.querySelector('.cancel-rating').addEventListener('click', () => {
      document.body.removeChild(popup);
      reject('Rating cancelled');
    });
  });
}

function attachEventListeners() {
  document.addEventListener('click', function(event) {
    const clickedElement = event.target;
    const card = clickedElement.closest('.watchlist-item');
    
    // Handle card click for details
    if (card && !clickedElement.closest('button')) {
      const sourceId = card.dataset.sourceId;
      const contentType = card.dataset.contentType;
      showDetailsPopup(sourceId, contentType);
      return;
    }
    
    // Handle button clicks
    const button = clickedElement.closest('.mark-watched, .mark-unwatched, .remove-item, .rate-item');
    if (!button) return;
    
    event.preventDefault();
    const sourceId = button.dataset.sourceId;
    const contentType = button.dataset.contentType;
    
    if (button.classList.contains('rate-item')) {
      const currentRating = parseInt(button.dataset.rating) || 0;
      handleRating(sourceId, contentType, currentRating);
    } else {
      const action = button.classList.contains('remove-item') ? 'removeItem' : 'toggleWatched';
      handleWatchlistAction(action, sourceId, contentType, button);
    }
  });
}

function updatePopupUI(popup, sourceId, inWatchlist, watched, rating) {
  const watchlistButton = popup.querySelector('.watchlist-toggle');
  const watchedButton = popup.querySelector('.watched-toggle');
  const rateButton = popup.querySelector('.rate-item');

  if (watchlistButton) {
    watchlistButton.classList.toggle('in-watchlist', inWatchlist);
    watchlistButton.innerHTML = `
      <i class="fas fa-bookmark ${inWatchlist ? 'text-warning' : 'text-muted'}"></i>
      <span class="watchlist-text ms-1">${inWatchlist ? 'Remove' : 'Add'}</span>
    `;
    watchlistButton.onclick = (event) => {
      event.preventDefault();
      event.stopPropagation();
      handleWatchlistAction(inWatchlist ? 'removeItem' : 'addItem', sourceId, watchlistButton.dataset.contentType, event.currentTarget)
        .then(data => {
          if (data.status === 'success') {
            if (inWatchlist) {
              // If removing, update both popup and main UI
              updatePopupUI(popup, sourceId, false, false, null);
              updateWatchlistUI(sourceId, false, false, null);
            } else {
              // If adding, update both popup and main UI
              const itemData = {
                ...extractDataFromPopup(popup, sourceId, watchlistButton.dataset.contentType),
                id: data.id
              };
              updatePopupUI(popup, sourceId, true, false, null);
              addItemToWatchlist(itemData);
            }
          }
        });
    };
  }

  if (watchedButton) {
    watchedButton.classList.toggle('watched', watched);
    watchedButton.innerHTML = `
      <i class="fas ${watched ? 'fa-eye-slash' : 'fa-eye'}"></i>
      <span class="watched-text ms-1">${watched ? 'Mark as Unwatched' : 'Mark as Watched'}</span>
    `;
    watchedButton.style.display = inWatchlist ? 'block' : 'none';
  }

  if (rateButton) {
    rateButton.style.display = (inWatchlist && watched) ? 'block' : 'none';
    if (rating) {
      rateButton.innerHTML = `
        <i class="fas fa-star"></i>
        <span class="rate-text">Rated (${rating})</span>
      `;
    } else {
      rateButton.innerHTML = `
        <i class="fas fa-star"></i>
        <span class="rate-text">Rate</span>
      `;
    }
  }
}

function showError(message) {
  const container = document.getElementById('recommendations-container');
  if (container) {
    container.innerHTML = `<div class="alert alert-danger">${message}</div>`;
  }
}

function removeWatchlistItem(event, sourceId, contentType) {
  event.preventDefault();
  event.stopPropagation();
  
  handleWatchlistAction('removeItem', sourceId, contentType, null);
}

function toggleWatched(event, sourceId, contentType) {
  event.preventDefault();
  event.stopPropagation();
  
  handleWatchlistAction('toggleWatched', sourceId, contentType, null);
}

function setupRatingHandlers(popup) {
  const rateButton = popup.querySelector('.rate-item');
  const ratingInterface = popup.querySelector('.rating-interface');
  const stars = popup.querySelectorAll('.star');
  
  if (!rateButton || !ratingInterface) return;

  rateButton.addEventListener('click', function(event) {
    event.preventDefault();
    event.stopPropagation();
    
    const sourceId = this.dataset.sourceId;
    const contentType = this.dataset.contentType;
    const currentRating = parseInt(this.dataset.rating) || 0;
    
    // Show rating interface next to the rate button
    ratingInterface.style.display = 'block';
    
    // Setup stars
    stars.forEach(star => {
      star.classList.toggle('active', parseInt(star.dataset.value) <= currentRating);
    });
  });

  // Handle star clicks
  stars.forEach(star => {
    star.addEventListener('click', () => {
      const value = parseInt(star.dataset.value);
      stars.forEach(s => s.classList.toggle('active', parseInt(s.dataset.value) <= value));
    });
  });

  // Handle submit/cancel
  popup.querySelector('.submit-rating').addEventListener('click', () => {
    const rating = popup.querySelectorAll('.star.active').length;
    const rateButton = popup.querySelector('.rate-item');
    const sourceId = rateButton.dataset.sourceId;
    const contentType = rateButton.dataset.contentType;

    submitRating(sourceId, contentType, rating).then(() => {
      popup.querySelector('.rating-interface').style.display = 'none';
      rateButton.classList.remove('rating-active');
      rateButton.classList.add('rated');
      rateButton.innerHTML = `
        <i class="fas fa-star"></i>
        <span class="rate-text">Rated (${rating})</span>
      `;
    });
  });

  popup.querySelector('.cancel-rating').addEventListener('click', () => {
    ratingInterface.style.display = 'none';
  });
}

function addItemToWatchlist(item) {
  const targetList = document.getElementById('unwatched-list');
  if (!targetList) {
    console.error('Target list not found for item:', item);
    return;
  }

  const newCard = document.createElement('div');
  newCard.className = 'card mb-3 watchlist-item';
  newCard.dataset.id = item.id;
  newCard.dataset.sourceId = item.source_id;
  newCard.dataset.contentType = item.content_type;
  newCard.setAttribute('role', 'article');
  newCard.setAttribute('aria-labelledby', `title-${item.source_id}`);

  // Using the structure from _watchlist_card.html.erb
  newCard.innerHTML = `
    <div class="row g-0">
      <div class="col-3">
        <img src="${item.poster_url}" class="img-fluid rounded-start" alt="${item.title} poster">
      </div>
      <div class="col-9">
        <div class="card-body position-relative">
          <h5 class="card-title mb-1" id="title-${item.source_id}">${item.title}</h5>
          <div class="card-text small mb-2">
            ${[item.country, item.release_year, item.content_type.charAt(0).toUpperCase() + item.content_type.slice(1)].filter(Boolean).join(", ")}<br>
            <strong>TMDb:</strong> ${item.vote_average}<br>
            ${item.genres.join(", ")}
          </div>
          <div class="d-flex gap-2 flex-md-nowrap flex-wrap">
            <button class="btn btn-sm btn-success mark-watched flex-grow-1 d-inline-flex align-items-center justify-content-center"
                    style="height: 31px; min-width: 104px"
                    data-source-id="${item.source_id}" 
                    data-content-type="${item.content_type}">
              <i class="fas fa-eye me-1"></i>
              <span>Watched</span>
            </button>
            <button class="btn btn-sm btn-primary rate-item flex-grow-1 d-inline-flex align-items-center justify-content-center"
                    style="height: 31px; min-width: 90px"
                    data-source-id="${item.source_id}" 
                    data-content-type="${item.content_type}"
                    data-rating="0">
              <i class="fas fa-star me-1"></i>
              <span>Rate</span>
            </button>
            <button class="btn btn-sm btn-danger remove-item flex-grow-1 d-inline-flex align-items-center justify-content-center"
                    style="height: 31px; min-width: 90px"
                    data-source-id="${item.source_id}" 
                    data-content-type="${item.content_type}">
              <i class="fas fa-trash-alt me-1"></i>
              <span>Remove</span>
            </button>
          </div>
        </div>
      </div>
    </div>
    <div class="drag-handle position-absolute top-0 start-0 p-2 text-white">
      <i class="fas fa-grip-vertical"></i>
    </div>
  `;

  targetList.appendChild(newCard);
  console.log('New card added to the DOM:', newCard);
  attachCardEventListeners(newCard);
}

function extractDataFromPopup(popup, sourceId, contentType) {
  // Helper to find paragraph by text content
  const findParagraphByText = (searchText) => {
    return Array.from(popup.querySelectorAll('p')).find(p => 
      p.textContent.includes(searchText)
    );
  };
  
  const title = popup.querySelector('h2').textContent;
  const posterUrl = popup.querySelector('img').src;
  const countryPara = findParagraphByText('Country:');
  const yearPara = findParagraphByText('Release Year:');
  const ratingPara = findParagraphByText('TMDb Rating:');
  const genresPara = findParagraphByText('Genres:');

  return {
    source_id: sourceId,
    content_type: contentType,
    title: title,
    poster_url: posterUrl,
    country: countryPara ? countryPara.textContent.split(':')[1].trim() : 'N/A',
    release_year: yearPara ? yearPara.textContent.split(':')[1].trim() : 'N/A',
    vote_average: ratingPara ? ratingPara.textContent.split(':')[1].split('(')[0].trim() : 'N/A',
    genres: genresPara ? genresPara.textContent.split(':')[1].trim().split(', ') : []
  };
}

function attachCardEventListeners(card) {
  // Watch/Unwatch button
  const watchButton = card.querySelector('.mark-watched, .mark-unwatched');
  if (watchButton) {
    watchButton.addEventListener('click', (event) => {
      event.preventDefault();
      event.stopPropagation();
      handleWatchlistAction('toggleWatched', watchButton.dataset.sourceId, watchButton.dataset.contentType, null);
    });
  }

  // Rate button
  const rateButton = card.querySelector('.rate-item');
  if (rateButton) {
    rateButton.addEventListener('click', (event) => {
      event.preventDefault();
      event.stopPropagation();
      handleRating(rateButton.dataset.sourceId, rateButton.dataset.contentType, parseInt(rateButton.dataset.rating) || 0);
    });
  }

  // Remove button
  const removeButton = card.querySelector('.remove-item');
  if (removeButton) {
    removeButton.addEventListener('click', (event) => {
      event.preventDefault();
      event.stopPropagation();
      handleWatchlistAction('removeItem', removeButton.dataset.sourceId, removeButton.dataset.contentType, null);
    });
  }
}
</script>
