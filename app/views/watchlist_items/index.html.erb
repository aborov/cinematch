<h1 class="mb-4">My Watchlist</h1>

<div class="row">
  <div class="col-md-6">
    <h2>Unwatched</h2>
    <div id="unwatched-list" class="watchlist-container" data-controller="sortable" data-sortable-resource-url="/watchlist_items/">
      <%= render partial: 'watchlist_card', collection: @unwatched_items.compact, as: :item %>
    </div>
  </div>

  <div class="col-md-6">
    <h2>Watched</h2>
    <div id="watched-list" class="watchlist-container" data-controller="sortable" data-sortable-resource-url="/watchlist_items/">
      <%= render partial: 'watchlist_card', collection: @watched_items.compact, as: :item %>
    </div>
  </div>
</div>

<%= render 'shared/details_modal' %>

<script>
document.addEventListener('DOMContentLoaded', function() {
  function handleWatchlistAction(action, sourceId, contentType, element) {
    let url, method;
    switch(action) {
      case 'markWatched':
        url = `/watchlist_items/${sourceId}/mark_watched?content_type=${contentType}`;
        method = 'PATCH';
        break;
      case 'markUnwatched':
        url = `/watchlist_items/${sourceId}/mark_unwatched?content_type=${contentType}`;
        method = 'PATCH';
        break;
      case 'removeItem':
        url = `/watchlist_items/${sourceId}?content_type=${contentType}`;
        method = 'DELETE';
        break;
    }
    fetch(url, {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
    })
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      if (data.status === 'success') {
        updateUI(action, element);
        updateWatchlistNavbar();
      } else {
        console.error('Error:', data.message);
        alert(data.message); // Show an alert to the user
      }
    })
    .catch(error => {
      console.error('Error:', error);
    });
  }

  function updateUI(action, element) {
    const watchlistItem = element.closest('.watchlist-item');
    const contentId = element.dataset.contentId;
    switch(action) {
      case 'markWatched':
        watchlistItem.remove();
        document.querySelector('.col-md-6:nth-child(2) .watchlist-container').appendChild(watchlistItem);
        element.textContent = 'Mark as Unwatched';
        element.classList.remove('btn-success', 'mark-watched');
        element.classList.add('btn-warning', 'mark-unwatched');
        element.onclick = function() { handleWatchlistAction('markUnwatched', contentId, this); };
        break;
      case 'markUnwatched':
        watchlistItem.remove();
        document.querySelector('.col-md-6:nth-child(1) .watchlist-container').appendChild(watchlistItem);
        element.textContent = 'Mark as Watched';
        element.classList.remove('btn-warning', 'mark-unwatched');
        element.classList.add('btn-success', 'mark-watched');
        element.onclick = function() { handleWatchlistAction('markWatched', contentId, this); };
        break;
      case 'removeItem':
        watchlistItem.remove();
        break;
    }
  }

  document.querySelectorAll('.mark-watched, .mark-unwatched, .remove-item').forEach(button => {
    button.addEventListener('click', function(event) {
      event.preventDefault();
      const action = this.classList.contains('mark-watched') ? 'markWatched' :
                     this.classList.contains('mark-unwatched') ? 'markUnwatched' :
                     'removeItem';
      const sourceId = this.dataset.sourceId;
      const contentType = this.dataset.contentType;
      handleWatchlistAction(action, sourceId, contentType, this);
    });
  });

  document.querySelectorAll('.watchlist-item').forEach(card => {
    card.addEventListener('click', function(event) {
      if (!event.target.closest('.btn')) {
        const id = this.dataset.sourceId;
        const type = this.dataset.contentType;
        const watched = this.querySelector('.mark-unwatched') !== null;
        showDetails(id, type, watched);
      }
    });
  });

  // Add this new code for Sortable
  const unwatchedList = document.getElementById('unwatched-list');
  const watchedList = document.getElementById('watched-list');

  [unwatchedList, watchedList].forEach(list => {
    new Sortable(list, {
      animation: 150,
      ghostClass: 'blue-background-class',
      handle: '.drag-handle', // Add this line
      onEnd: function(evt) {
        const itemId = evt.item.getAttribute('data-id');
        const newIndex = evt.newIndex;
        const watched = evt.to.id === 'watched-list';

        updateItemPosition(itemId, newIndex, watched);
      }
    });
  });

  function updateItemPosition(itemId, newIndex, watched) {
    fetch(`/watchlist_items/${itemId}/update_position`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ position: newIndex, watched: watched })
    })
    .then(response => response.json())
    .then(data => {
      if (data.status === 'success') {
        console.log('Position updated successfully');
      } else {
        console.error('Error updating position:', data.message);
      }
    })
    .catch(error => console.error('Error:', error));
  }
});

function showDetails(id, type, watched) {
  console.log('showDetails called with:', id, type, watched);
  fetch(`/recommendations/${id}?type=${type}`)
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log('Recommendation data received:', data);
      var country = data.production_countries ? data.production_countries.map(c => c.name === 'United States of America' ? 'USA' : c.name).join(', ') : 'N/A';
      return { ...data, inWatchlist: true, watched: watched, country: country };
    })
    .then(data => {
      const modalContent = generateModalContent(data);
      document.getElementById('popup-details').innerHTML = modalContent;
      new bootstrap.Modal(document.getElementById('detailsModal')).show();
    })
    .catch(error => {
      console.error('Error:', error);
      alert('An error occurred while fetching details. Please try again.');
    });
}

function generateModalContent(data) {
  var details = `
    <div class="row">
      <div class="col-md-4">
        <img src="https://image.tmdb.org/t/p/w500${data.poster_path}" class="img-fluid rounded" alt="${data.title || data.name} poster" role="img">
      </div>
      <div class="col-md-8">
        <div class="d-flex justify-content-between align-items-start mb-2">
          <h2 class="text-warning mb-0">${data.title || data.name}</h2>
          <div class="d-flex flex-column align-items-end">
            <button class="btn btn-primary watchlist-toggle ${data.inWatchlist ? 'in-watchlist' : ''}" 
                    onclick="${data.inWatchlist ? `removeWatchlistItem(event, '${data.source_id}', '${data.content_type}')` : `toggleWatchlist(event, '${data.source_id}', '${data.content_type}')`}"
                    data-id="${data.id}"
                    data-source-id="${data.source_id}"
                    data-content-type="${data.content_type}"
                    aria-label="${data.inWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}">
              <i class="fas fa-bookmark ${data.inWatchlist ? 'text-warning' : 'text-muted'}" 
                 alt="${data.inWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}"></i>
              <span class="watchlist-text ms-1">${data.inWatchlist ? 'Remove' : 'Add'}</span>
            </button>
            ${data.inWatchlist ? `
              <button class="btn btn-outline-primary watched-toggle mt-2 ${data.watched ? 'watched' : ''}" 
                      onclick="toggleWatched(event, '${data.source_id}', '${data.content_type}')"
                      data-id="${data.id}"
                      data-source-id="${data.source_id}"
                      data-content-type="${data.content_type}"
                      aria-label="${data.watched ? 'Mark as Unwatched' : 'Mark as Watched'}">
                <i class="fas ${data.watched ? 'fa-eye-slash' : 'fa-eye'}" 
                   alt="${data.watched ? 'Mark as Unwatched' : 'Mark as Watched'}"></i>
                <span class="watched-text ms-1">${data.watched ? 'Mark as Unwatched' : 'Mark as Watched'}</span>
              </button>
            ` : ''}
          </div>
        </div>
        ${data.content_type === 'movie' ? 
          `<p><strong>Runtime:</strong> ${data.runtime || 'N/A'} minutes</p>` :
          `<p><strong>Number of Seasons:</strong> ${data.number_of_seasons || 'N/A'}</p>
           <p><strong>Number of Episodes:</strong> ${data.number_of_episodes || 'N/A'}</p>
           <p><strong>In Production:</strong> ${data.in_production ? 'Yes' : 'No'}</p>`
        }
        <p><strong>Release Year:</strong> ${(data.release_date || data.first_air_date || '').substring(0, 4)}</p>
        <p><strong>Country:</strong> ${data.country}</p>
        <p><strong>TMDb Rating:</strong> ${data.vote_average} (${data.vote_count} votes)</p> 
        <p><strong>Genres:</strong> ${(data.genres || []).map(g => typeof g === 'string' ? g : g.name).join(', ')}</p>
        <p><strong>Description:</strong> ${data.overview}</p>
        ${data.content_type === 'movie' ?
          `<p><strong>Director(s):</strong> ${(data.credits?.crew || []).filter(c => c.job === 'Director').map(d => d.name).join(', ') || 'N/A'}</p>` :
          `<p><strong>Creator(s):</strong> ${data.creators ? data.creators.join(', ') : 'N/A'}</p>`
        }
        <p><strong>Cast:</strong> ${(data.credits?.cast || []).slice(0, 5).map(c => c.name).join(', ') || 'N/A'}</p>
        <p><strong>Spoken Languages:</strong> ${(data.spoken_languages || []).map(l => l.name).join(', ') || 'N/A'}</p>
      </div>
    </div>
    <div class="embed-responsive embed-responsive-16by9 mb-3">
      ${data.trailer_url ? `
        <iframe class="embed-responsive-item" width="100%" height="315" src="${data.trailer_url.replace('watch?v=', 'embed/')}" allowfullscreen title="${data.title || data.name} trailer"></iframe>
      ` : '<p>No video available</p>'}
    </div>
  `;
  return details;
}

function updateWatchlistNavbar() {
  Promise.all([
    fetch('/watchlist_items/count').then(response => {
      if (!response.ok) throw new Error('Count fetch failed');
      return response.json();
    }),
    fetch('/watchlist_items/recent').then(response => {
      if (!response.ok) throw new Error('Recent fetch failed');
      return response.json();
    })
  ])
    .then(([countData, recentData]) => {
      const badge = document.querySelector('#watchlist-count');
      if (badge) {
        badge.textContent = countData.count;
        badge.style.display = countData.count > 0 ? 'inline-block' : 'none';
      }

      const dropdown = document.querySelector('#watchlist-dropdown');
      if (dropdown) {
        if (recentData.items && recentData.items.length > 0) {
          dropdown.innerHTML = recentData.items.map(item => `
            <li><a class="dropdown-item" href="/watchlist_items">
              <img src="${item.poster_url}" alt="${item.title}" class="me-2" style="width: 30px; height: 45px; object-fit: cover;">
              <span>${item.title} (${item.year})</span>
            </a></li>
          `).join('') + `
            <li><hr class="dropdown-divider"></li>
            <li><a class="dropdown-item text-primary" href="/watchlist_items">View All</a></li>
          `;
        } else {
          dropdown.innerHTML = '<li><span class="dropdown-item">No items in watchlist</span></li>';
        }
      }
      console.log('Watchlist navbar updated successfully');
      console.log('Count data:', countData);
      console.log('Recent data:', recentData);
    })
    .catch(error => console.error('Error updating watchlist navbar:', error));
}

function toggleWatchlist(event, id, type) {
  event.preventDefault();
  event.stopPropagation();
  console.log('toggleWatchlist called');

  const button = event.currentTarget;
  const inWatchlist = !button.classList.contains('in-watchlist');
  const sourceId = button.dataset.sourceId;

  // Immediately update UI
  updateWatchlistUI(id, inWatchlist);

  const method = inWatchlist ? 'POST' : 'DELETE';
  const url = inWatchlist ? '/watchlist_items' : `/watchlist_items/${sourceId}?content_type=${type}`;

  fetch(url, {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
    },
    body: JSON.stringify({ source_id: sourceId, content_type: type })
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      console.log('Watchlist toggled:', data);
      updateWatchlistNavbar();
    } else {
      console.error('Error toggling watchlist:', data);
      // Revert UI change if the server request failed
      updateWatchlistUI(id, !inWatchlist);
    }
  })
  .catch(error => {
    console.error('Error toggling watchlist:', error);
    // Revert UI change if there was a network error
    updateWatchlistUI(id, !inWatchlist);
  });
}

function updateWatchlistUI(sourceId, inWatchlist) {
  console.log('updateWatchlistUI called with:', sourceId, inWatchlist);
  
  const popupButton = document.querySelector(`#popup-details .watchlist-toggle[data-source-id="${sourceId}"]`);
  const card = document.querySelector(`.watchlist-item[data-source-id="${sourceId}"]`);

  if (popupButton) {
    console.log(`Updating button UI for popup with sourceId:`, sourceId);
    popupButton.classList.toggle('in-watchlist', inWatchlist);
    const icon = popupButton.querySelector('i.fa-bookmark');
    if (icon) {
      icon.classList.toggle('text-warning', inWatchlist);
      icon.classList.toggle('text-muted', !inWatchlist);
    }
    const span = popupButton.querySelector('.watchlist-text');
    if (span) {
      span.textContent = inWatchlist ? 'Remove' : 'Add';
    }
    popupButton.setAttribute('aria-label', inWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist');
  }

  if (card && !inWatchlist) {
    console.log(`Removing card UI for sourceId:`, sourceId);
    card.remove();
  }
}

function toggleWatched(event, id, type) {
  event.preventDefault();
  event.stopPropagation();
  console.log('toggleWatched called');

  const button = event.currentTarget;
  const watched = !button.classList.contains('watched');
  const sourceId = button.dataset.sourceId;

  // Immediately update UI
  updateWatchedUI(sourceId, watched);

  const url = `/watchlist_items/${sourceId}/${watched ? 'mark_watched' : 'mark_unwatched'}?content_type=${type}`;
  fetch(url, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
    },
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      console.log('Watched status updated:', data);
      updateWatchlistNavbar();
    } else {
      console.error('Error updating watched status:', data);
      // Revert UI change if the server request failed
      updateWatchedUI(sourceId, !watched);
    }
  })
  .catch(error => {
    console.error('Error updating watched status:', error);
    // Revert UI change if there was a network error
    updateWatchedUI(sourceId, !watched);
  });
}

function updateWatchedUI(sourceId, watched) {
  console.log('updateWatchedUI called with:', sourceId, watched);
  
  const popupButton = document.querySelector(`#popup-details .watched-toggle[data-source-id="${sourceId}"]`);
  const card = document.querySelector(`.watchlist-item[data-source-id="${sourceId}"]`);

  if (popupButton) {
    console.log(`Updating button UI for popup with sourceId:`, sourceId);
    popupButton.classList.toggle('watched', watched);
    const icon = popupButton.querySelector('i');
    if (icon) {
      icon.classList.toggle('fa-eye', !watched);
      icon.classList.toggle('fa-eye-slash', watched);
    }
    const span = popupButton.querySelector('.watched-text');
    if (span) {
      span.textContent = watched ? 'Mark as Unwatched' : 'Mark as Watched';
    }
    popupButton.setAttribute('aria-label', watched ? 'Mark as Unwatched' : 'Mark as Watched');
  }

  if (card) {
    console.log(`Updating card UI for sourceId:`, sourceId);
    const watchedButton = card.querySelector('.mark-watched, .mark-unwatched');
    if (watchedButton) {
      watchedButton.classList.toggle('btn-success', !watched);
      watchedButton.classList.toggle('btn-warning', watched);
      watchedButton.classList.toggle('mark-watched', !watched);
      watchedButton.classList.toggle('mark-unwatched', watched);
      watchedButton.textContent = watched ? 'Mark as Unwatched' : 'Mark as Watched';
    }
    
    // Move the card to the appropriate list
    const sourceList = watched ? document.getElementById('unwatched-list') : document.getElementById('watched-list');
    const targetList = watched ? document.getElementById('watched-list') : document.getElementById('unwatched-list');
    if (sourceList.contains(card)) {
      targetList.appendChild(card);
    }
  }
}

function removeWatchlistItem(event, sourceId, contentType) {
  event.preventDefault();
  event.stopPropagation();
  console.log('removeWatchlistItem called');

  // Immediately update UI
  updateWatchlistUI(sourceId, false);

  const url = `/watchlist_items/${sourceId}?content_type=${contentType}`;
  fetch(url, {
    method: 'DELETE',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
    },
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      console.log('Item removed from watchlist:', data);
      updateWatchlistNavbar();
    } else {
      console.error('Error removing item from watchlist:', data);
      // Revert UI change if the server request failed
      updateWatchlistUI(sourceId, true);
    }
  })
  .catch(error => {
    console.error('Error removing item from watchlist:', error);
    // Revert UI change if there was a network error
    updateWatchlistUI(sourceId, true);
  });
}
</script>
